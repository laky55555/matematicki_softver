{"kernelspec":{"display_name":"Python 2 (SageMath)","language":"python","name":"python2"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"# Riješavanje sustava jednadžbi\nVelik broj problema u matematici, a i šire moguće je zapisati pomoću matrica. Zbog toga nam rad s matricama postaje vrlo važan. Matrice najčešće koristimo za izračunavanja nekih sustava linearnih jednadžbi, te nerijetko nalazimo na probleme u kojim matrice imaju neku \"pravilniju\" strukturu. Kako sustavi mogu biti ogromnih veličina svaka dodatna informacija o matricama je važna, te ju želimo iskoristiti tako da uštedimo vrijeme račnanja, memoriju za spremanje itd.\nU slijdećim primjerima vidjet ćemo nekoliko različitih tipova matrica i pokušati riješiti neke sustave linearnih jednadžbi s njima na nekoliko različitih načina i provjeriti što se s njima događa."}
{"cell_type":"markdown","metadata":{},"source":"Inicijalizacija problema koji zelimo rješiti:"}
{"cell_type":"code","execution_count":434,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"import numpy as np\nimport scipy.linalg as lin\nimport timeit\n\nvelicina_matrice = 1000\n#inicijalizacija matrice i vektora\nA = np.array([[0, 3, 0, 2, 0], \n     [1, 1, 1, 0, 2], \n     [1, 3, 0, 2, 4], \n     [0, 3, 0, 4, 4], \n     [4, 4, 1, 0, 3]])\n\nb = np.array([1, 2, 1, 2, 1])\nb = b.transpose()\n\n#random inicijalizacija pozitivno definitne matrice i vektora\nA = np.random.rand(velicina_matrice,velicina_matrice)\nb = np.random.rand(velicina_matrice,1)\nA = np.dot(A,A.transpose())\n"}
{"cell_type":"markdown","metadata":{},"source":"1: $A*x=b$ => $x=A^{-1}*b$, izračunamo inverz od matrice, te pomnožimo inverz s vektorom. Loše jer je traženje inverza nepotrebno, i dugo traje."}
{"cell_type":"code","execution_count":23,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"start = timeit.default_timer() \nA_inv = lin.inv(A)\nx1 = A_inv.dot(b)\nstop = timeit.default_timer()\nvrijeme_inverz = stop - start"}
{"cell_type":"markdown","metadata":{},"source":"2: Napravimo LU faktorizaciju s pivotiranjem, te onda riješimo sustav $A = P*L*U$ gdje su L i U donje, odnosno gornje trokutaste matrice, a P matrica permutiranja.\nPrvo permutiramo vektor b s matricom P  $b₂=P^{-1}*b$, zatim nam ostaje $L*U*x=b₂$, koji lagano rješavamo supstitucijom jer su L i U trokutaste. $U*x=L^{^-1}*b₂$, te na kraju $x=U^{^-1}*L^{^-1}*b₂$"}
{"cell_type":"code","execution_count":24,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"start = timeit.default_timer() \nP, L, U = lin.lu(A)\nb2 = lin.inv(P).dot(b)\nb3 = lin.inv(L).dot(b2)\nx2 = lin.inv(U).dot(b3)\nstop = timeit.default_timer()\nvrijeme_pivotiranje = stop - start"}
{"cell_type":"markdown","metadata":{},"source":"3: U scipy-u imamo biblioteku koja sadrži funkciju za računanje sustava, pa iskoristimo ju na našu dobivenu L U faktorizaciju"}
{"cell_type":"code","execution_count":25,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"start = timeit.default_timer() \nP, L, U = lin.lu(A)\nb2 = lin.solve(P,b)\nb3 = lin.solve_triangular(L,b2, lower=True)\nx3 = lin.solve_triangular(U,b3)\nstop = timeit.default_timer()\nvrijeme_pivotiranje_solve = stop - start"}
{"cell_type":"markdown","metadata":{},"source":"4: Ako pozovemo funkciju solve direktno python bi trebao pronaći optimalan način računanja."}
{"cell_type":"code","execution_count":26,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"start = timeit.default_timer() \nx4 = lin.solve(A,b)\nstop = timeit.default_timer()\nvrijeme_solve = stop - start"}
{"cell_type":"markdown","metadata":{},"source":"5: Ako imamo neka dodatana znanja o matrici npr. ako je matrica pozitivno definitna možemo funkciju slove poboljšati tako da joj kažemo da radi s pozitivnom definitnom matricom."}
{"cell_type":"code","execution_count":27,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def je_li_pozitivno_definitna(x):\n    return np.all(np.linalg.eigvals(x) > 0)\n\nif(je_li_pozitivno_definitna(A)):\n    start = timeit.default_timer() \n    R = lin.cho_factor(A)\n    x5 = lin.cho_solve(R, b)\n    stop = timeit.default_timer()\n    vrijeme_choleski = stop - start\n"}
{"cell_type":"code","execution_count":61,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Za matricu ranga 3 dobiju se iduci podaci:\n                              Metode   Vremena\n0                     pomoću inverza  0.000533\n1                 pomoću pivotiranja  0.045053\n2  pomocu pivotiranja i solve metode  0.053677\n3                       pomocu solve  0.000295\n4            pomocu soleve choleskog  0.000561\nJesu li dobivena rjesenja jednaka?\nTrue\nNajbrze racunanje je: pomocu solve i vrijeme potrebno za izracun je: 0.000295162200928\n"}],"source":"import pandas as pd \n\ndef je_su_li_vektori_jednaki(prvi, *ostali):\n        for vektor in ostali:\n            if(not np.allclose(prvi, vektor)):\n                return False\n        return True\n    \ndef indeks_najbrzeg_racunanja(vremena):\n    minimum = vremena[0]\n    indeks = 0\n    for i in range(len(vremena)):\n        if(vremena[i] < minimum):\n            minimum = vremena[i]\n            indeks = i\n    return indeks\n            \n\nmetode = [\"pomoću inverza\", \"pomoću pivotiranja\", \"pomocu pivotiranja i solve metode\", \"pomocu solve\", \"pomocu soleve choleskog\"]\nvremena = [vrijeme_inverz, vrijeme_pivotiranje, vrijeme_pivotiranje_solve,vrijeme_solve, vrijeme_choleski]\ntablica = list(zip(metode, vremena))\n\nprint(\"Za matricu ranga \" + str(velicina_matrice) + \" dobiju se iduci podaci:\")\ndf = pd.DataFrame(data = tablica, columns=['Metode', 'Vremena'])\nprint(df)\n\nprint(\"Jesu li dobivena rjesenja jednaka?\\n\" + str(je_su_li_vektori_jednaki(x1,x2,x3,x4,x5)))\nprint(\"Najbrze racunanje je: \" + metode[indeks_najbrzeg_racunanja(vremena)] + \" i vrijeme potrebno za izracun je: \" + str(min(vremena)))"}
{"cell_type":"markdown","metadata":{},"source":"# Aproksimacija i interpolacija funkcija\nJoš jedan problem koji se često javlja u numeričkoj matematici je interpolacija nekih točaka/funkcija polinomima. To je važno jer ako s funkcijama želimo raditi neke zahtjevnije operacije poput integriranja, ili deriviranja često je to vrlo težak i dugotrajan postupak, stoga se umjesto tih funkcija koriste polinomi koji ih dobro opisuju. Za pronaći takve polinome postoji monogo različitih metoda, te ne postoji univerzalna koja odgovara svakoj funkciji već je potrebno za svaku funkciju koju želimo interpolirati odabrati odgovarajuću metodu.\nU nastavku se nalazi jedan primjer koji pokazuje kako se koristi interpolacija u praksi."}
{"cell_type":"markdown","metadata":{},"source":"Imamo podatke u csv formatu o vremenu kroz jednu godinu. Naš zadatak je da iz podataka izvučemo podatke vezane uz proljeće (21.3-21.6), te na tim podacima pokušamo napisati funkcije koje najbolje aproksimiraju kretanje temperature. Za baratanje s podacima u pythonu jedan od boljih library-a je pandas. Prvo ćemo učitati podakte i upoznat se s njihovom strukturom, a zatim se pozabaviti s problemom."}
{"cell_type":"code","execution_count":393,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"smc-blob::2531cb25-c579-4954-8c98-8535c43819bf","text/plain":"smc-blob::d28bbd9d-b12c-4f03-89c8-0c7cf2a2ea53"},"execution_count":393,"metadata":{},"output_type":"execute_result"}],"source":"data=pd.read_csv(\"weather_year.csv\")\n\ndata.columns = [\"date\", \"max_temp\", \"mean_temp\", \"min_temp\", \"max_dew\",\n                \"mean_dew\", \"min_dew\", \"max_humidity\", \"mean_humidity\",\n                \"min_humidity\", \"max_pressure\", \"mean_pressure\",\n                \"min_pressure\", \"max_visibilty\", \"mean_visibility\",\n                \"min_visibility\", \"max_wind\", \"mean_wind\", \"min_wind\",\n                \"precipitation\", \"cloud_cover\", \"events\", \"wind_dir\"]\n\ndata.head()"}
{"cell_type":"code","execution_count":394,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"smc-blob::a253ea82-fa39-4654-b433-b99548bf50fb","text/plain":"        mean_temp\ncount  366.000000\nmean    55.683060\nstd     18.436506\nmin     11.000000\n25%     41.000000\n50%     59.000000\n75%     70.750000\nmax     89.000000"},"execution_count":394,"metadata":{},"output_type":"execute_result"}],"source":"#osnovna statistika promatranog stupca\ndata[['mean_temp']].describe()\n\n"}
{"cell_type":"code","execution_count":395,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"<matplotlib.axes._subplots.AxesSubplot at 0x7f9c73666e10>"},"execution_count":395,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::9a76ff94-47be-4546-bbda-71764194942c","text/plain":"<matplotlib.figure.Figure at 0x7f9c735464d0>"},"metadata":{},"output_type":"display_data"}],"source":"#kretanje temperatura kroz godinu\ndata.mean_temp.hist()"}
{"cell_type":"code","execution_count":396,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"#kako je tip podataka za vrijeme string, ako zelimo baratati s datumima, moramo ih zapisati u odgovarajući oblik\nfrom datetime import datetime\nimport scipy.interpolate as inter\nimport matplotlib.pyplot as plt\ndata.date = data.date.apply(lambda d: datetime.strptime(d, \"%Y-%m-%d\"))\ndata.index = data.date"}
{"cell_type":"code","execution_count":397,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"#izvucemo trazene podatke o proljecu\nproljece = data[data.date < datetime(2012,6,21)]\nproljece = proljece[proljece.date >=datetime(2012,3,21)]\nproljece = proljece.ix[:,0:4]\nproljece.index = [x for x in range(0,92)]\nproljece_svaki_drugi = proljece[proljece.index % 2 == 0]\nproljece_svaki_treci = proljece[proljece.index % 3 == 0]\nproljece_svaki_cetvrti = proljece[proljece.index % 4 == 0]"}
{"cell_type":"code","execution_count":398,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"<matplotlib.axes._subplots.AxesSubplot at 0x7f9c733fec50>"},"execution_count":398,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::90d9d569-168b-41f8-bb07-2459b17c94b1","text/plain":"<matplotlib.figure.Figure at 0x7f9c7342df90>"},"metadata":{},"output_type":"display_data"},{"data":{"text/plain":"<matplotlib.figure.Figure at 0x7f9c73348550>"},"metadata":{},"output_type":"display_data"},{"data":{"image/png":"smc-blob::394f0480-6cfc-4408-b450-cbff4c33b556","text/plain":"<matplotlib.figure.Figure at 0x7f9c732f4550>"},"metadata":{},"output_type":"display_data"}],"source":"#histogram najmanjih, prosjecnih i najvecih temperatura koje se pojavljuju u proljece\nproljece.mean_temp.hist()\nproljece.min_temp.hist()\nproljece.max_temp.hist()\nplt.figure()\nproljece.plot.hist(alpha = 0.6)"}
{"cell_type":"code","execution_count":411,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"<matplotlib.axes._subplots.AxesSubplot at 0x7f9c72a72910>"},"execution_count":411,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::f2c4782b-c0a2-4d17-a5bd-7760e9307629","text/plain":"<matplotlib.figure.Figure at 0x7f9c72a33dd0>"},"metadata":{},"output_type":"display_data"}],"source":"boja = dict(boxes='Red', whiskers='DarkOrange', medians='DarkBlue', caps='Gray')\nproljece.plot.box(color=boja)"}
{"cell_type":"code","execution_count":414,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"0.9436006388496827"},"execution_count":414,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::7c2c23fa-3cac-4c4f-8988-b4c5da680f4b","text/plain":"<matplotlib.figure.Figure at 0x7f9c7870bd10>"},"metadata":{},"output_type":"display_data"}],"source":"#linearna aproksimacija kretanja temperatura\nproljece.min_temp.plot()\nproljece.mean_temp.plot()\nproljece.max_temp.plot()\nproljece.mean_temp.corr(proljece.max_temp)"}
{"cell_type":"markdown","metadata":{},"source":"Sad ćemo vidjeti kako se neke aproksimacije ponašaju u odnosu na to koliko točaka imaju prilikom računanje aproksimacije.\nZa primjer pogledat ćemo što se događa imamo podatke o svakom drugom, trećem i četvrtom danu. "}
{"cell_type":"code","execution_count":400,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::bccc622b-4fa6-45ac-b3eb-a9052d7d0e0f","text/plain":"<matplotlib.figure.Figure at 0x7f9c7342d510>"},"metadata":{},"output_type":"display_data"}],"source":"fig, ax = plt.subplots(figsize=(16,8))\nax.plot(proljece.index, proljece.mean_temp, 'ro', label='orginalni podaci')\n\n\nx = np.linspace(0,90,1000)\nn = np.arange(0, 92, 2)\n\ninter1 = inter.Akima1DInterpolator(n, proljece_svaki_drugi.mean_temp)\ny_interp1 = inter1(x)\n\ninter2 = inter.interp1d(n, proljece_svaki_drugi.mean_temp)\ny_interp2 = inter2(x)\n\ninter3 = inter.PchipInterpolator(n, proljece_svaki_drugi.mean_temp)\ny_interp3 = inter3(x)\n\nax.plot(x, y_interp1, 'r', label='Akima 1D interpolacija')\nax.plot(x, y_interp2, 'g', label='Linearna interpolacija')\nax.plot(x, y_interp3, 'b', label='Pchip interpolacija')\nax.legend(loc=3);"}
{"cell_type":"code","execution_count":401,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::08f97782-9c60-4659-a5e5-6886d948b612","text/plain":"<matplotlib.figure.Figure at 0x7f9c7305fc50>"},"metadata":{},"output_type":"display_data"}],"source":"fig, ax = plt.subplots(figsize=(16,8))\nax.plot(proljece.index, proljece.mean_temp, 'ro', label='orginalni podaci')\n\n\nx = np.linspace(0,90,1000)\nn = np.arange(0, 92, 3)\n\ninter1 = inter.Akima1DInterpolator(n, proljece_svaki_treci.mean_temp)\ny_interp1 = inter1(x)\n\ninter2 = inter.interp1d(n, proljece_svaki_treci.mean_temp)\ny_interp2 = inter2(x)\n\ninter3 = inter.PchipInterpolator(n, proljece_svaki_treci.mean_temp)\ny_interp3 = inter3(x)\n\nax.plot(x, y_interp1, 'r', label='Akima 1D interpolacija')\nax.plot(x, y_interp2, 'g', label='Linearna interpolacija')\nax.plot(x, y_interp3, 'b', label='Pchip interpolacija')\nax.legend(loc=3);\n"}
{"cell_type":"code","execution_count":452,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::e819a7a9-8095-4b23-bc1a-25f66b9790f2","text/plain":"<matplotlib.figure.Figure at 0x7f9c713d0750>"},"metadata":{},"output_type":"display_data"}],"source":"fig, ax = plt.subplots(figsize=(16,8))\nax.plot(proljece.index, proljece.mean_temp, 'ro', label='orginalni podaci')\n\n\nx = np.linspace(0,88,1000)\nn = np.arange(0, 92, 4)\n\ninter1 = inter.Akima1DInterpolator(n, proljece_svaki_cetvrti.mean_temp)\ny_interp1 = inter1(x)\n\ninter2 = inter.interp1d(n, proljece_svaki_cetvrti.mean_temp)\ny_interp2 = inter2(x)\n\ninter3 = inter.PchipInterpolator(n, proljece_svaki_cetvrti.mean_temp)\ny_interp3 = inter3(x)\n\nax.plot(x, y_interp1, 'r', label='Akima 1D interpolacija')\nax.plot(x, y_interp2, 'g', label='Linearna interpolacija')\nax.plot(x, y_interp3, 'b', label='Pchip interpolacija')\nax.legend(loc=3);"}
{"cell_type":"markdown","metadata":{},"source":"Još jedan zanimljiv način interpolacije jest interpolacija sa splajnovima."}
{"cell_type":"code","execution_count":454,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::0a8df9ae-b1c7-46e3-b84a-f55e95b7e0aa","text/plain":"<matplotlib.figure.Figure at 0x7f9c713f1910>"},"metadata":{},"output_type":"display_data"}],"source":"fig, ax = plt.subplots(figsize=(16,8))\nax.plot(proljece.index, proljece.mean_temp, 'ro', label='orginalni podaci')\n\n\nx = np.linspace(-1,91,1000)\nn2 = np.arange(0, 92, 2)\nn3 = np.arange(0, 92, 3)\nn4 = np.arange(0, 92, 4)\n\ninter1 = inter.InterpolatedUnivariateSpline(n2, proljece_svaki_drugi.mean_temp)\ny_interp1 = inter1(x)\n\ninter2 = inter.InterpolatedUnivariateSpline(n3, proljece_svaki_treci.mean_temp)\ny_interp2 = inter2(x)\n\ninter3 = inter.InterpolatedUnivariateSpline(n4, proljece_svaki_cetvrti.mean_temp)\ny_interp3 = inter3(x)\n\nax.plot(x, y_interp1, 'r', label='Spline interpolacija sa svakom drugo tockom')\nax.plot(x, y_interp2, 'g', label='Spline interpolacija sa svakom trecom tockom')\nax.plot(x, y_interp3, 'b', label='Spline interpolacija sa svakom cetvrtom tockom')\nax.legend(loc=2);"}